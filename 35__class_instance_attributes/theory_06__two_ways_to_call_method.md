## Два способа вызова метода

У нас есть класс `A`:
* с атрибутом `name`
* и методом `method()`

```python
class A:
    def __init__(self, name):
        self.name = name
        
    def method(self):
        print("Вызван method() у объекта", self)
```

---

### 1. Вызов через объект (стандартный)

```python
a = A()
a.method()
```

**Что происходит на самом деле?**

Когда мы вызываем `a.method()`, интерпретатор автоматически:

1. ищет метод `method` в классе `A`,
2. обнаруживает, что это **метод экземпляра класса A**, ожидающий первый параметр `self`,
3. **подставляет объект `a` в качестве первого аргумента**.

То есть:

```
a.method()  →  A.method(a)
```

Таким образом, `a.method()` — это просто синтаксический сахар.

В реальности выполняется:

### 2. Вызов метода через класс

```python
A.method(a)
```

Здесь мы вручную вызываете функцию `method`, описанную внутри класса `A`,
и в качестве аргумента явно передаём `self`, в качестве экземпляра класса.

То есть здесь нет автоматической подстановки — всё делается вручную.

Таким образом, об способа `a.method()` и `A.method(a)` — одно и то же действие.  
Разница — только в форме записи.

---

### Резюме

| Синтаксис     | Что происходит логически  | Кто задаёт `self`  |
| ------------- | ------------------------- | ------------------ |
| `a.method()`  | Автоподстановка `self`    | Язык автоматически |
| `A.method(a)` | Ручная подстановка `self` | Вы, вручную        |

✔ Оба вызова приводят к **одинаковому исполнению кода метода**.   
✔ Отличается только синтаксис.
