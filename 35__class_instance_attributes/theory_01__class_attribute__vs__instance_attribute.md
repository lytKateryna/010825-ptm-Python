### 1. Создание атрибута класса `general` и атрибута экземпляра класса

* **Атрибут класса** создаётся ВНЕ `__init__()`
* **Атрибут экземпляра класса** создаётся ВНУТРИ `__init__()`

```python
class A:
    general = 100   # атрибут класса

    def __init__(self, x):
        self.x = x   # атрибут экземпляра


a1 = A(5)
a2 = A(10)
```

### 2. Где "виден" каждый из атрибутов?

* **Атрибут класса** виден и в класса, и в каждом экземпляре класса
* **Атрибут экземпляра класса** виден ИСКЛЮЧИТЕЛЬНО внутри ТОЛЬКО этого экземпляра

```python
# class attribute
print(a1.general)  # 100
print(a2.general)  # 100
print(A.general)   # 100

# instance attribute
print(a1.x)  # 5
print(a2.x)  # 10
```

---

### 3. Как изменить атрибут класса `general`?

* 3.1. Через имя класса:

```python
A.general = 500


print(a1.general)  # 500
print(a2.general)  # 500
```

* 3.2. Через экземпляр класса с помощью метода `__class__`:

```python
a1.__class__.general = 777

print(a1.general)  # 777
print(a2.general)  # 777
```

### 4. Что будет, если написать `a1.general = ...`

Вот важная ловушка:
* это НЕ меняет атрибут класса.
* это создаёт НОВЫЙ атрибут экземпляра класса.

```python
a1.general = 999

print(a1.general)  # 999  ← свой собственный атрибут
print(a2.general)  # 777  ← атрибут класса
print(A.general)   # 777
```

Иными словами атрибут экземпляра класса экранирует отображение атрибута класса.  
Если удалить атрибут экземпляра класса, то сразу станет виден атрибут класса:


```python
del a1.general

print(a1.general)  # 777  ← атрибут класса (снова виден)
print(a2.general)  # 777  ← атрибут класса
print(A.general)   # 777
```

### 5. Можно ли добавлять атрибуты экземпляра минуя `__init__()`?

Можно.  
Но не нужно.  
Поскольку PEP 8 считает это плохой практикой:

* Атрибуты экземпляров должны быть определены:
  * в `__init__`
  * или в других методах класса, но ВСЕГДА внутри класса

* Причины:
  * Программист должен видеть в классе, 
    * **какие именно** атрибуты будет иметь объект.
  * Динамическое их добавление вне класса делает интерфейс объекта 
    * неявным 
    * и непредсказуемым.

### 6. Назначение атрибутов по умолчанию

```python
class B:
    def __init__(self, x=10):
        self.x = x

b1 = B()
b2 = B(20)
print(b1, b2)  # 10, 20
```

## Весь код полностью:

```python
class A:
    general = 100   # атрибут класса

    def __init__(self, x):
        self.x = x   # атрибут экземпляра


a1 = A(5)
a2 = A(10)


# class attribute
print(a1.general)  # 100
print(a2.general)  # 100
print(A.general)   # 100

# instance attribute
print(a1.x)  # 5
print(a2.x)  # 10

# ======== Меняем general =========
# --- вариант 1 ---
A.general = 500

print(a1.general)  # 500
print(a2.general)  # 500
print(A.general)   # 500

# --- вариант 2---
a1.__class__.general = 777

print(a1.general)  # 777
print(a2.general)  # 777
print(A.general)   # 777

# ======== Неудачная попытка изменить general =========
a1.general = 999

print(a1.general)  # 999  ← свой собственный атрибут
print(a2.general)  # 777  ← атрибут класса
print(A.general)   # 777

# ======== Исправляем ошибку =========
del a1.general    # ← удаляем свой собственный атрибут

print(a1.general)  # 777  ← атрибут класса (снова виден)
print(a2.general)  # 777  ← атрибут класса
print(A.general)   # 777

# ======= Назначение атрибутов по умолчанию =======

class B:
    def __init__(self, x=10):
        self.x = x

        
b1 = B()
b2 = B(20)
print(b1, b2)  # 10, 20
```
