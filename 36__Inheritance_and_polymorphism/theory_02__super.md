### 1. Что такое `super()`

`super()` — это встроенная функция, которая позволяет 
* обратиться к родительскому классу из класса наследника
* и вызвать его (родителя) методы.

Функция `super()` полезна, когда:

* Нужно расширить поведение родительского метода, а не полностью его заменять.
* Есть **множественное наследование**, и порядок вызова методов (`MRO`) важен.

---

### 2. Пример "жёсткого" базового наследования (неправильно!)

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} издает звук")

class Dog(Animal):
    def __init__(self, name, breed):
        Animal.__init__(self, name)  # вызов конструктора родителя
        self.breed = breed

    def speak(self):
        Animal.speak(self)  # вызов метода speak родителя
        print(f"{self.name} говорит: Гав!")
```

---

### 3. Пример "гибкого" базового наследования (правильный)

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} издает звук")

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # вызов конструктора родителя
        self.breed = breed

    def speak(self):
        super().speak()  # вызов метода speak родителя
        print(f"{self.name} говорит: Гав!")

dog = Dog("Шарик", "Дворняжка")
dog.speak()

# Шарик издает звук
# Шарик говорит: Гав!
```

**Что произошло?**:

1. `super().__init__(name)` — вызывает конструктор родителя `Animal.__init__`, чтобы инициализировать `name`.
2. `super().speak()` — вызывает метод `speak` родителя, прежде чем добавить новое поведение:
   * Сначала срабатывает `super().speak()` родителя (`Шарик издает звук`)
   * А затем уже дополненная часть `speak()` наследника (`Шарик говорит: Гав!`)

---

### 4. Почему не использовать напрямую `Animal.__init__(self, name)`?

Технически можно, но `super()` имеет преимущества:

* Работает корректно при **множественном наследовании**.
* Не нужно жёстко указывать имя родителя, что делает код гибче.
* Следует **MRO (Method Resolution Order)**, Python автоматически определяет порядок вызова методов.

---

### 5. Пример множественного наследования

```python
class A:
    def say(self):
        print("A")

class B(A):
    def say(self):
        print("B")
        super().say()

class C(A):
    def say(self):
        print("C")
        super().say()

class D(B, C):
    def say(self):
        print("D")
        super().say()

d = D()
d.say()
```

**Вывод:**

```
D
B
C
A
```

**Здесь `super()` использует **MRO**, чтобы пройти по всем родителям в правильном порядке**:

```python
print(D.mro())
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

---

### 6. Итоги

* `super()` — безопасный способ вызвать метод родителя.
* Используется для **расширения функционала** родительского класса.
* Обязателен при **множественном наследовании**, чтобы MRO сработал правильно.
* Часто используется в конструкторах `__init__`.

