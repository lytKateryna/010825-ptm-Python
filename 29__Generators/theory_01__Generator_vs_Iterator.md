## Определение

**Генератор** — это частный случай итератора.

## Но чем они отличаются?

### 1. По способу создания

**Итератор**:

* нужно реализовать вручную два метода:

  * `__iter__()` — возвращает сам итератор
  * `__next__()` — возвращает следующее значение или `StopIteration`
* это больше кода

Пример собственного итератора:

```python
class Counter:
    def __init__(self, n):
        self.n = n
        self.i = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self.i < self.n:
            self.i += 1
            return self.i
        raise StopIteration
```

**Генератор**:

* создаётся автоматически либо:

  * с помощью `yield`
  * генераторного выражения
* не нужно писать класс и методы

Пример генератора:

```python
def counter(n):
    i = 0
    while i < n:
        i += 1
        yield i
```

---

### 2. По управлению состоянием

**Итератор**:

* вы сами вручную управляете состоянием (переменные, индексы)

**Генератор**:

* Python автоматически сохраняет контекст, локальные переменные и место выполнения между вызовами `next()`
* работа функции «замораживается» в точке `yield` и продолжается потом

---

### 3. По простоте написания

* Генератор проще, нагляднее и быстрее создавать.  
* Итератор — более низкоуровневый механизм, используемый «под капотом».

---

### 4. По способности принимать значения ПОСЛЕ запуска

* Генератор может *принимать* значения извне через `send()`  
* Итератор — нет, только выдаёт.

```python
value = gen.send(10)
```

---

### 5. По расходу памяти и производительности

* И генератор, и итератор ленивы и экономят память.  
* Но генераторы часто эффективнее, так как Python оптимизирует работу с `yield`.

---

## Итого

| Свойство                                | Итератор                 | Генератор                             |
| --------------------------------------- | ------------------------ | ------------------------------------- |
| Как создаётся                           | вручную (класс + методы) | автоматически (`yield` или выражение) |
| Кто управляет состоянием                | программист              | Python                                |
| Может принимать значения через `send()` | ❌                        | ✔                                     |
| Удобство                                | низкое                   | высокое                               |
| Является итератором?                    | ✔                        | ✔ (частный случай)                    |

