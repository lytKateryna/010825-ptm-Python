# Базовый root (корневой) логгер

## Пример

`log_config.py`

```python
import logging

# Создаём два хендлера
file_handler = logging.FileHandler("app.log", encoding="utf-8")
console_handler = logging.StreamHandler()

# Настраиваем формат
formatter = logging.Formatter("%(asctime)s [%(levelname)s] (%(name)s): %(message)s")
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Конфигурация root logger через basicConfig
logging.basicConfig(
    level=logging.DEBUG,
    handlers=[file_handler, console_handler],  # ← передаём сразу несколько
    force=True  # очищает старые хендлеры, чтобы не дублировались сообщения
)

# Проверим
logging.info("Сообщение INFO — попадёт и в файл, и в консоль")
logging.error("Сообщение ERROR — тоже в оба места")
```

---

## Что происходит "под капотом"?

1. При импорте `import logging` Python создаёт **root logger** — это объект `logging.getLogger()` без имени.
2. Далее создаются два обработчика (хэндлера): `file_handler` и `stream_handler`
3. Cоздаётся форматтер (`formatter`)для форматирования вывода
4. Которые далее добавляется к каждому хэндлеру.
5. Далее, при вызове метода `logging.basicConfig()`, к корневому логгеру будут добавлены:

   * два отформатированных обработчика,
   * задан минимальный уровень логирования
   * и сброшены все предыдущие возможные настройки корневого логгера (`force=True`)

После этого все вызовы `logging.info()`, `logging.debug()`, `logging.error()` и т.д.
будут обращаются именно к этому `root logger`.


ВАЖНО: возможность добавлять более одного хэндлера в `basicConfig()` появилась в версии Python3.8

---

## Как другие файлы используют тот же root logger?

В другом файле (например `module_a.py`, мы просто пишем:

```python
import logging
import log_config

log = logging.getLogger(__name__)
log.info("Привет из другого модуля!")
```

В результате мы:

1. `import logging` - импортируем модуль логирования
2. `import log_config` - импортируем настройки `root логгера`
3. `log = logging.getLogger(__name__)` - создаём дочерний логгер `log`.

Если в дочерний логгер `log` не добавить своих хендлеров,  
то он **наследует хендлеры root logger’а**, то есть:

* его сообщения будут писаться туда же (в `app.log`),
* с тем же форматом и уровнем.

## Плюсы и минусы такого подхода

| Категория              | Плюсы ✅                                                          | Минусы ⚠️                                                                       |
| ---------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| **Простота**           | Минимум кода, быстро настраивается.                              | Нет гибкости при масштабировании (например, разные форматы для разных модулей). |
| **Переиспользуемость** | Отдельный файл `log_config.py` можно подключать во всех модулях. | Импорт модуля всегда инициализирует логгер (нет ленивой загрузки).              |
| **Совместимость**      | Работает во всех современных версиях Python (3.8+).              | В старых версиях Python параметр `handlers` не поддерживается.                  |
| **Управляемость**      | Легко изменить формат, уровень, обработчики — в одном месте.     | При сложных проектах потребуется конфигурация через `dictConfig` или YAML.      |
| **Отладка**            | Формат даёт понятную информацию: время, уровень, модуль.         | Нет разделения по контексту (например, для HTTP-запросов или потоков).          |
| **Производительность** | Минимальные накладные расходы.                                   | Без ротации файл может быстро вырасти.                                          |
