### Что такое проблема ромба (diamond problem)?

**Diamond problem** возникает при **множественном наследовании**, когда структура классов выглядит так:

```
      A
     / \
    B   C
     \ /
      D
```
* Во всех родительских классах есть метод `show()`, но в каждом классе он имеет разный функционал
* Класс `D` наследует от `B` и `C`.
* `B` и `C` наследуют от одного класса `A`.
* Вопрос: чей именно метод `show()` унаследует дочерний класс `D`?


---

#### Пример

```python
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        print("B")

class C(A):
    def show(self):
        print("C")

class D(B, C):
    pass

d = D()
d.show()
print(D.__mro__)
```

### Объяснение

* `D` наследует от `B` и `C`.
* Метод `show` есть у `B`, `C` и `A`.
* Python использует **C3-линеаризацию**, чтобы определить **MRO (Method Resolution Order)**.

**Вывод программы:**

```
B
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```

### Как Python решает `diamond problem`? (Алгоритм C3 linearization)

* Сначала поиск идёт у родителей (`B` и `C`)
* Как только метод находится, его дальнейший поиск прекращается
* Порядок поиска у родителей идёт слева-направо 
  * (поэтому в нашем случае `show()` берётся из `B`)
* Если метод на найден у родителей (`B` и `C`), то общий родитель родителей (`A`) проверяется ТОЛЬКО 1 раз 
  * (чтобы избежать дублирования)


**Таким образом**:

* **Методы не вызываются дважды.**
* Порядок поиска предсказуемый и безопасный.


---

### Порядок разрешения методов при наследовании `__mro__` (MRO)

**Method Resolution Order** — это атрибут класса,  
который показывает порядок поиска методов и атрибутов при множественном наследовании.

**Синтаксис**

```python
ClassName.__mro__
```

* Возвращает **tuple** с классами в порядке поиска методов.
* Обычно используется для отладки и анализа множественного наследования.


**В нашем случае**:
```
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```
MRO показывает, что поиск будет идти именно в этом порядке.

---

### Ещё одно доказательство успешного решения `diamond problem` в Python

Здесь мы 
* оставим тот же "ромбический" порядок наследования.  
* но добавим в каждый `__init__()` функцию `super()`
  * которая принудительно будет вызвать `__init__()` своего родителя


```python
class A:
    def __init__(self):
        print("Init A")

class B(A):
    def __init__(self):
        print("Init B")
        super().__init__()

class C(A):
    def __init__(self):
        print("Init C")
        super().__init__()

class D(B, C):
    def __init__(self):
        print("Init D")
        super().__init__()

d = D()
```

**Вывод:**

```
Init D
Init B
Init C
Init A
```

* В каждом дочернем конструкторе (`__init__`) идёт вызов метод родителя.
* Тем не менее общий родитель `A` для `B` и `C` вызывается **только один раз**.
* Порядок вызова соответствует **MRO класса D**.

