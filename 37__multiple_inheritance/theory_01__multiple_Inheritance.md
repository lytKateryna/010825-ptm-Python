### **Множественное наследование**

**Множественное наследование** — это возможность класса наследоваться сразу от нескольких базовых классов.  

В семействе языков высокого уровня множественное наследование поддерживают **далеко** не все.   
Кроме `Python`, множественное наследование ещё есть в `C++`, `Ruby`.  
А вот `Java`, `C#`, `Swift`, `Go`, `JavaScript` — нет.

В Python это реализуется следующим образом:


```python
class Person:
    def __init__(self, name):
        self.name = name

    def greet(self):
        print(f"Hello, my name is {self.name}")

    def info(self):
        print(f"Метод из класса Person")


class Worker:
    def work(self):
        print("I am working!")

    def info(self):
        print(f"Метод из класса Worker")


class Student:
    def study(self):
        print("I am studying!")

    def info(self):
        print(f"Метод из класса Student")


class WorkingStudent(Person, Worker, Student):
    def __init__(self, name):
        super().__init__(name)  # Инициализация Person


ws = WorkingStudent("Alice")
ws.greet()      # метод из Person
ws.work()       # метод из Worker
ws.study()      # метод из Student
ws.info()       # Из какого класса будет унаследован этот метод?
```

Как видим, каждый из родительских классов имеет:

1. Свой собственный уникальный метод (`greet`, `work` и `study`)
2. Метод `info`: общее название, разное содержание

---

## Особенности множественного наследования

1. **Порядок поиска методов (MRO – Method Resolution Order):**
   Python использует алгоритм **C3-линеаризации** для определения порядка наследования методов и атрибутов
   (решение "проблемы ромба" (`diamond problem`).

   * Сначала ищется в самом классе.
   * Затем в родительских классах слева направо, учитывая их наследников.

2. **Конфликты имён:**
   Если два родительских класса имеют метод с одинаковым именем, 
   будет вызван метод того класса, который идёт первым.

3. **Вызов конструктора родительских классов:**
   Для корректной инициализации базовых классов удобно использовать `super()`.

4. **Гибкость и расширяемость:**
   Множественное наследование позволяет комбинировать поведение нескольких классов, избегая дублирования кода.

