## Публичные, защищённые и приватные аттрибуты 

Инкапсуляция означает:
* Скрыть (упаковать, спрятать) что-то внутрь какой-то оболочки (капсулы)

В ООП (вообще и в Python в частности) под инкапсуляцией понимается
* размещение данных и/или логики внутрь объекта, 
* чтобы при необходимости легко получить (вызвать) через dot-notation

Сам смысл этого "сокрытия лишнего" можно рассматривать (понимать) в двух аспектах:

1. "Убрать с глаз долой, чтобы не мешалось"
  * Атрибуты создаются в `__init__()` и затем не требуют специальной передачи в методы
  * поскольку уже и так становятся часть объекта

2. "Спрятать, чтобы не брали без спросу"
  * Получение и/или изменение данных возможно ТОЛЬКО при соблюдении определённых условий


Вот именно второй аспект понятия "Инкапсуляция" мы и рассмотрим в этом блоке.


### 1. Публичные атрибуты (`public attributes`)

**Принцип**: *"Приходи кто хочешь, и бери сколько захочешь"*

* Доступны **из любого места**: внутри класса, из подклассов, из внешнего кода.
* Обычно **не имеют специальных подчёркиваний**.
* Используются по умолчанию.


**Пример:**

```python
class Person:
    def __init__(self, name):
        self.name = name  # публичный атрибут

p = Person("Alice")
print(p.name)  # доступно извне
```

---

### 2. Защищённые атрибуты (`_protected attributes`)

**Принцип**: *"Приходи кто хочешь, но бери только для внутреннего использования"*

* Обозначаются **одним подчёркиванием `_` перед именем**: `_attribute`.
* **Соглашение**: к ним **не следует обращаться извне класса**, но Python не запрещает это.
* Часто используются для **наследования** и для внутреннего контроля.

**Пример:**

```python
class Person:
    def __init__(self, name):
        self._name = name  # защищённый атрибут

p = Person("Bob")
print(p._name)  # работает, но считается плохой практикой
```

---

### 3. Приватные атрибуты (`__private attributes`)

**Принцип**: *"Доступ без геттеров и сеттеров запрещён"*

* Обозначаются **двумя подчёркиваниями `__` перед именем**: `__attribute`.
* Python применяет **name mangling** — имя атрибута преобразуется в `_ClassName__attribute`.
* Это делает **сложнее случайный доступ извне** (но всё равно можно получить при желании).
* Но самое главное: это предполагает доступ ТОЛЬКО через геттеры и сеттеры.

**Пример:**

```python
class Person:
    def __init__(self, name):
        self.__name = name  # приватный атрибут

p = Person("Charlie")
# print(p.__name)  # ❌ AttributeError
print(p._Person__name)  # ✅ доступ через name mangling
```

---

### **Итоговая таблица**

| Тип        | Синтаксис | Доступ извне | Примечание                                  |
| ---------- | --------- | ------------ | ------------------------------------------- |
| Публичный  | `name`    | свободный    | обычные атрибуты                            |
| Защищённый | `_name`   | нежелателен  | соглашение, не строгий запрет               |
| Приватный  | `__name`  | ограничен    | name mangling, защита от случайного доступа |

