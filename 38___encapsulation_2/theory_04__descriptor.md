### 1. Проблема с обычными геттерами и сеттерами

Представим класс с приватным атрибутом и сеттером, который проверяет возраст:

```python
class Person:
    def __init__(self, age):
        self.__age = age  # напрямую присвоили, минуя сеттер

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("Возраст не может быть отрицательным!")
        self.__age = value
```

---

### 2. Что происходит при создании объекта?

```python
p = Person(-10)  # прямо при __init__ присвоили "неверный" возраст
print(p.age)     # -10, сеттер не сработал!
```

✅ Внимание: проверка в сеттере **не сработала**, потому что мы обошли её, присвоив значение напрямую в `__init__`.

---

### 3. Почему это важно?

* Если объект создаётся с **множеством атрибутов**, которые требуют проверки (возраст, зарплата, email и т.д.), 
  * то геттеры и сеттеры **легко обходятся** через прямое присвоение.
* Это создаёт **лазейки для некорректных данных**, особенно при инициализации или внутренней модификации.

---

### 4. Решение через дескрипторы

Дескриптор позволяет **перехватывать присвоение в любом месте**, включая `__init__`:

```python
class Age:
    def __get__(self, instance, owner):
        return instance._age

    def __set__(self, instance, value):
        if value < 0:
            raise ValueError("Возраст не может быть отрицательным!")
        instance._age = value

class Person:
    age = Age()  # дескриптор управляет атрибутом
    def __init__(self, age):
        self.age = age  # теперь Age.__set__ всегда вызывается

p = Person(-10)  # ValueError! 
```

---

### Резюме

* Геттеры и сеттеры удобны для внешнего API класса, 
  * но **не защищают атрибуты при инициализации или обходе приватности**.
* Дескрипторы позволяют **централизованно и гарантированно контролировать доступ и присвоение атрибутов**.

